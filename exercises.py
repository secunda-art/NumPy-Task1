import numpy as np

def linear_system(A, b):
    """ Решает систему линейных уравнений A*x + b = 0, заданную в матричной форме

    Аргументы:
        - A:np.ndarray - матрица (nxn) коэффициентов системы линейных уравнений.
        - b:np.ndarray - вектор размера (nx1)

    Возвращает:
        - np.ndarray - вектор размера (nx1), если решение существует
        - None, если решения не существует

    Указания:
        - используйте метод np.linalg.det для проверки обратимости матрицы
        - способ 1:
            - используйте метод np.linalg.inv для инвертирования матрицы
            - авторское решение занимает 63 символа
        - способ 2:
            - используйте метод np.linalg.solve для решения линейной системы
            - авторское решение занимает 64 символа
    """
    return np.linalg.solve(A,-b) if np.linalg.det(A) else None

def chessboard_pattern(n):
    """ Создает двумерный массив, заполненный нулями и единицами в шахматном порядке.
        Поле с индексом [0, 0] должно быть равно нулю. Например, для n = 2:
        [
            [0, 1],
            [1, 0]
        ]
        Для n = 4:
        [
            [0, 1, 0, 1],
            [1, 0, 1, 0],
            [0, 1, 0, 1],
            [1, 0, 1, 0]
        ]

    Аргументы:
        - n:int - четное неотрицательное целое число (n = 0, 2, 4, ...)

    Возвращает:
        - np.ndarray размера (nxn), dtype=np.int64

    Увазания:
        - для инициализации массива нулями можно использовать функцию np.zeros
        - для инициализации массива единицами можно использовать функцию np.ones
        - используйте возможности индексации массивов numpy
        - авторское решение занимает 4 строки
    """
    board = np.zeros((n, n), dtype=np.int64)
    board[1::2, ::2] = 1 # нечетная строка, четный столбец
    board[::2, 1::2] = 1 # четная строка, нечетный столбец
    return board

def sort_by_key(arr, fcn):
    """ Сортирует массив arr, используя в качестве ключа функцию fcn
        (подобно стандартной функции sorted с параметром key)

    Аргументы:
        - arr:np.ndarray - одномерный массив
        - fcn:callable - функция, которая преобразует элементы массива

    Возвращает:
        - np.ndarray - отсортированный массив того же размера, что и исходный

    Указания:
        - рассмотрите возможность использования функции np.argsort
        - авторское решение занимает 32 символоа
    """
    return arr[np.argsort(fcn(arr))]


def row_magnitude(arr):
    """ Возвращает корень из суммы квадратов значений в каждой строке двумерного массива.
        Например, для массива [
            [1, 0, 0],
            [3, 4, 0]
        ]
        будет возвращено [
            [1],
            [5]
        ]

    Аргументы:
        - arr:np.ndarray - двумерный массив размера (n, m)

    Возвращает:
        - np.ndarray - массив размера (n, 1)

    Указания:
        - в решении не следует использовать циклы
        - размеры (n, ) и (n, 1) - это разные размеры
        - авторское решение занимает 63 символа
    """
    return np.sqrt(np.sum(arr**2, axis = 1, keepdims=True))


def outlier_filtering(arr, nsigma):
    """ Выполняет отбраковку далеких от среднего значений. А именно, пусть
        mean и std - среднее значение и среднеквадратичное отклонение элементов
        массива arr. Элемент массива arr[i] следует отбраковать, если
            arr[i] < mean - nsigma * std
        или 
            arr[i] > mean + nsigma * std

    Аргументы:
        - arr:np.ndarray - одномерный массив, содержащий более одного элемента

    Возвращает:
        - np.ndarray

    Указания:
        - используйте индексирование элементов массива с помощью булевой маски
        - пересечение булевых массивов numpy можно выполнить с помощью оператора &
        - относительный порядок оставшихся элементов не должен измениться
        - авторское решение занимает 2 строки
    """
    mean, std = np.mean(arr), np.std(arr)
    return arr[(arr >= mean - nsigma * std) * (arr <= mean + nsigma * std)]


def add_row_col(arr):
    """ Выполняет две операции: 
        - Добавляет снизу массива строку, равную удвоенной первой строке
        - Добавляет справа столбец, равный удвоенному первому столбцу
        Например, для массива [
            [1,2],
            [3,5],
            [6,9],
            [11,15]
        ]
        будет возвращено [
            [1,2,2],
            [3,5,6],
            [6,9,12],
            [11,15,22],
            [2,4,4]
        ]
        
    Аргументы:
        - arr:np.ndarray - двумерный массив размера (n, m)

    Возвращает:
        - np.ndarray - массив размера (n+1, m+1)

    Указания:
        - в решении не следует использовать циклы
        - авторское решение занимает 2 строчки
    """
    arr = np.vstack([arr, arr[0] * 2]) # добавляем строчку
    return np.hstack([arr, (arr[:, 0] * 2).reshape(-1, 1)]) # добавляем стобец



def array_centering(arr):
    """ Выполняет центрирование массива размером nxm. Пусть массив
        содержит измерения m величин в n экспериментах, тогда для
        центрирования массива необходимо:
        - Найти среднее по n строкам для каждого из m столбцов
        - Отнять от данных каждого из столбцов соответствующее среднее
        
    Аргументы:
        - arr:np.ndarray - двумерный массив размера (n, m)
    
    Возвращает:
        - np.ndarray - массив размера (n, m)
        
    Указания:
        - в решении не следует использовать циклы
        - авторское решение занимает 2 строчки
    """
    mean = np.mean(arr, axis=0)
    return arr - mean



def substitute(arr):
    """ Создает копию исходного массива, в которой значения массива, 
        делящиеся на два без остатка, заменены на нуль. Например, массив
        np.array([1, 2, 2, 3, 2, 1, 0]) перейдёт в 
        np.array([1, 0, 0, 3, 0, 1, 0]).
        
    Аргументы:
        - arr: np.ndarray, (n,)
    
    Возвращает:
        - np.ndarray - массив (n,)
        
    Указания:
        - исходный массив arr должен остаться нетронутым
        - авторское решение занимает одну строчку
    """
    return np.where(arr % 2, arr, 0)



def flatten(arr):
    """ Получает на вход массив одномерных массивов arr и возвращает одномерный 
        'плоский' массив, который содержит в себе элементы исходных массивов.
    
    Аргументы:
        - arr: массив массивов
    
    Возвращает:
        - np.ndarray
        
    Указания:
        - решение занимает одну строчку
        - одним из вариантов решения является использование функции np.concatenate
    """
    return np.concatenate(arr)

def is_duplicate(arr):
    """ Возвращает массив, в котором на позиции первого вхождения в массив arr 
        стоит False, а на позиции дубликата - True. Например, при аргументе 
        функции np.array([0, 0, 3, 0, 2, 4, 2, 2, 2, 2]) должен вернуться массив
        np.array([False, True, False, True, False, False, True, True, True, True])
        
    Аргументы:
        - arr: одномерный массив
    
    Возвращает:
        - np.ndarray
        
    Указания:
        - не использовать циклы
        - воспользоваться функцией np.unique
        - авторское решение занимает 4 строчки
    """
    nums, index = np.unique(arr, return_index=True)
    res = np.ones_like(arr, dtype=bool)
    res[index] = False
    return res